// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2019-2022 Second State INC

#include "common/types.h"
#include "runtime/instance/module.h"
#include "wasinnfunc.h"
#include "wasinnmodule.h"

#include <algorithm>
#include <cstdint>
#include <fstream>
#include <gtest/gtest.h>
#include <numeric>
#include <vector>

using WasmEdge::Host::WASINN::Backend;
using WasmEdge::Host::WASINN::ErrNo;
namespace {
[[maybe_unused]] WasmEdge::Runtime::Instance::ModuleInstance *createModule() {
  using namespace std::literals::string_view_literals;
  WasmEdge::Plugin::Plugin::load(
      std::filesystem::u8path("../../../plugins/wasi_nn/"
                              "wasmedgePluginWasiNN" WASMEDGE_LIB_EXTENSION));
  //   "libwasmedgePluginWasiNN" WASMEDGE_LIB_EXTENSION));
  if (const auto *Plugin = WasmEdge::Plugin::Plugin::find("wasi_nn"sv)) {
    if (const auto *Module = Plugin->findModule("wasi_nn"sv)) {
      return Module->create().release();
    }
  }
  return nullptr;
}

[[maybe_unused]] inline std::vector<uint8_t>
readEntireFile(const std::string &Path) {
  std::ifstream Fin(Path, std::ios::binary | std::ios::ate);
  if (!Fin) {
    return {};
  }
  Fin.seekg(0, std::ios::end);
  std::vector<uint8_t> Buf(static_cast<uint32_t>(Fin.tellg()));
  Fin.seekg(0, std::ios::beg);
  if (!Fin.read(reinterpret_cast<char *>(Buf.data()),
                static_cast<uint32_t>(Buf.size()))) {
    return {};
  }
  Fin.close();
  return Buf;
}

template <typename T>
[[maybe_unused]] void
writeBinaries(WasmEdge::Runtime::Instance::MemoryInstance &MemInst,
              std::vector<T> Binaries, uint32_t Ptr) noexcept {
  std::copy(Binaries.begin(), Binaries.end(), MemInst.getPointer<T *>(Ptr));
}

void writeUInt32(WasmEdge::Runtime::Instance::MemoryInstance &MemInst,
                 uint32_t Value, uint32_t &Ptr) {
  uint32_t *BufPtr = MemInst.getPointer<uint32_t *>(Ptr);
  *BufPtr = Value;
  Ptr += 4;
}

[[maybe_unused]] void
writeFatPointer(WasmEdge::Runtime::Instance::MemoryInstance &MemInst,
                uint32_t PtrVal, uint32_t PtrSize, uint32_t &Ptr) {
  writeUInt32(MemInst, PtrVal, Ptr);
  writeUInt32(MemInst, PtrSize, Ptr);
}

} // namespace

int main() {
  // auto *NNMod = dynamic_cast<WasmEdge::Host::WasiNNModule *>(createModule());
  // if (NNMod == nullptr)
  //   std::cout << "++++++++++++++++++++++=" << std::endl;
  // std::cout << WasmEdge::Plugin::Plugin::plugins().size() << std::endl;

  // load dll file
  auto Path =
      std::filesystem::u8path("../../../plugins/wasi_nn/"
                              "wasmedgePluginWasiNN" WASMEDGE_LIB_EXTENSION);
  auto Path1 = std::filesystem::u8path("../../../lib/api/"
                                       "wasmedge" WASMEDGE_LIB_EXTENSION);

  // auto Path =
  // std::filesystem::u8path("C:/Users/11626/Documents/openvino/wasm_openvino/wasmedge/build/plugins/wasi_nn/wasmedgePluginWasiNN.dll");

  // auto Path = std::filesystem::u8path("../../../plugins/wasi_nn/hello.txt");

  std::error_code Error;
  auto Status = std::filesystem::status(Path, Error);
  std::cout << "the error number is " << Error << std::endl;
  if (!Error) {
    if (std::filesystem::is_regular_file(Status))
      std::cout << "this is a file  " << std::endl;
  }
  std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
               "++++++++++++++++++++++++"
            << std::endl;
  // auto Handle = LoadLibraryExA(LPCSTR(Path.c_str()), nullptr, 0);
  // std::cout<<" the handle is  "<< Handle <<std::endl;

  auto Lib = std::make_shared<WasmEdge::Loader::SharedLibrary>();
  if (auto Res = Lib->load(Path1); !Res) {
    std::cout << "load dll path1 file  wrong" << std::endl;
  }

  if (auto Res = Lib->load(Path); !Res) {
    std::cout << "load dll file  wrong" << std::endl;
  }

  boost::winapi::HMODULE_ HANDLE =
      boost::winapi::load_library_ex(Path.c_str(), nullptr, 0);
  std::cout << "the handle is " << HANDLE << std::endl;
  // std::wstring module_directory;
  //   if (FilePathApartDirectory(GetModulePathName(module_handle),
  //   module_directory))
  //       return module_directory;

  // Create the calling frame with memory instance.
  WasmEdge::Runtime::Instance::ModuleInstance Mod("");
  Mod.addHostMemory(
      "memory", std::make_unique<WasmEdge::Runtime::Instance::MemoryInstance>(
                    WasmEdge::AST::MemoryType(400)));

  // auto *MemInstPtr = Mod.findMemoryExports("memory");
  // ASSERT_TRUE(MemInstPtr != nullptr);
  // auto &MemInst = *MemInstPtr;
  // WasmEdge::Runtime::CallingFrame CallFrame(nullptr, &Mod);
}

// namespace {
// WasmEdge::Runtime::Instance::ModuleInstance *createModule() {
//   using namespace std::literals::string_view_literals;
//   WasmEdge::Plugin::Plugin::load(
//       std::filesystem::u8path("../../../plugins/wasi_nn/"
//                               "wasmedgePluginWasiNN"
//                               WASMEDGE_LIB_EXTENSION));
//   //   "libwasmedgePluginWasiNN" WASMEDGE_LIB_EXTENSION));
//   if (const auto *Plugin = WasmEdge::Plugin::Plugin::find("wasi_nn"sv)) {
//     if (const auto *Module = Plugin->findModule("wasi_nn"sv)) {
//       return Module->create().release();
//     }
//   }
//   return nullptr;
// }

// inline std::vector<uint8_t> readEntireFile(const std::string &Path) {
//   std::ifstream Fin(Path, std::ios::binary | std::ios::ate);
//   if (!Fin) {
//     return {};
//   }
//   Fin.seekg(0, std::ios::end);
//   std::vector<uint8_t> Buf(static_cast<uint32_t>(Fin.tellg()));
//   Fin.seekg(0, std::ios::beg);
//   if (!Fin.read(reinterpret_cast<char *>(Buf.data()),
//                 static_cast<uint32_t>(Buf.size()))) {
//     return {};
//   }
//   Fin.close();
//   return Buf;
// }

// template <typename T>
// void writeBinaries(WasmEdge::Runtime::Instance::MemoryInstance &MemInst,
//                    std::vector<T> Binaries, uint32_t Ptr) noexcept {
//   std::copy(Binaries.begin(), Binaries.end(), MemInst.getPointer<T *>(Ptr));
// }

// void writeUInt32(WasmEdge::Runtime::Instance::MemoryInstance &MemInst,
//                  uint32_t Value, uint32_t &Ptr) {
//   uint32_t *BufPtr = MemInst.getPointer<uint32_t *>(Ptr);
//   *BufPtr = Value;
//   Ptr += 4;
// }

// void writeFatPointer(WasmEdge::Runtime::Instance::MemoryInstance &MemInst,
//                      uint32_t PtrVal, uint32_t PtrSize, uint32_t &Ptr) {
//   writeUInt32(MemInst, PtrVal, Ptr);
//   writeUInt32(MemInst, PtrSize, Ptr);
// }

// template <typename T>
// std::vector<size_t> classSort(const std::vector<T> &Array) {
//   std::vector<size_t> Indices(Array.size());
//   std::iota(Indices.begin(), Indices.end(), 0);
//   std::sort(Indices.begin(), Indices.end(),
//             [&Array](size_t Left, size_t Right) -> bool {
//               // Sort indices according to corresponding array element.
//               return Array[Left] > Array[Right];
//             });
//   return Indices;
// }
// } // namespace

// template <typename T> void printErr(T str) {
//   testing::internal::CaptureStderr();
//   std::cout << str << std::endl;
//   testing::internal::CaptureStderr();
// }

// TEST(WasiNNTest, OpenVINOBackend) {
//   // auto tmp = WasmEdge::Plugin::Plugin::load(std::filesystem::u8path(
//   //   "../../../plugins/wasi_nn/"
//   //   "wasmedgePluginWasiNN" WASMEDGE_LIB_EXTENSION));
//   // printErr(tmp);

//   // Create the wasmedge_process module instance.
//   auto *NNMod = dynamic_cast<WasmEdge::Host::WasiNNModule *>(createModule());
//   EXPECT_TRUE(1 == 2) << "the plugins' size is : "
//                       << WasmEdge::Plugin::Plugin::plugins().size();
//   ASSERT_TRUE(NNMod != nullptr);
//   testing::internal::CaptureStderr();
//   std::cout << "my ++++++++ test";
//   testing::internal::CaptureStderr();
//   // Create the calling frame with memory instance.
//   WasmEdge::Runtime::Instance::ModuleInstance Mod("");
//   Mod.addHostMemory(
//       "memory",
//       std::make_unique<WasmEdge::Runtime::Instance::MemoryInstance>(
//                     WasmEdge::AST::MemoryType(400)));
//   auto *MemInstPtr = Mod.findMemoryExports("memory");
//   ASSERT_TRUE(MemInstPtr != nullptr);
//   auto &MemInst = *MemInstPtr;
//   WasmEdge::Runtime::CallingFrame CallFrame(nullptr, &Mod);

//   // Load the files.
//   std::vector<uint8_t> TensorData =
//       readEntireFile("./wasinn_openvino_fixtures/tensor-1x224x224x3-f32.bgr");
//   std::vector<uint8_t> XmlRead =
//       readEntireFile("./wasinn_openvino_fixtures/mobilenet.xml");
//   std::vector<uint8_t> WeightRead =
//       readEntireFile("./wasinn_openvino_fixtures/mobilenet.bin");

//   std::vector<uint32_t> TensorDim{1, 3, 224, 224};
//   uint32_t BuilderPtr = UINT32_C(0);
//   uint32_t LoadEntryPtr = UINT32_C(0);
//   uint32_t SetInputEntryPtr = UINT32_C(0);
//   uint32_t OutBoundPtr = UINT32_C(410 * 65536);
//   uint32_t StorePtr = UINT32_C(65536);

//   // Return value.
//   std::array<WasmEdge::ValVariant, 1> Errno = {UINT32_C(0)};

//   // Temp. values.
//   std::vector<WasmEdge::Host::WASINN::Graph> NNGraphTmp;
//   std::vector<WasmEdge::Host::WASINN::Context> NNContextTmp;

//   // Get the function "load".
//   auto *FuncInst = NNMod->findFuncExports("load");
//   EXPECT_NE(FuncInst, nullptr);
//   EXPECT_TRUE(FuncInst->isHostFunction());
//   auto &HostFuncLoad =
//       dynamic_cast<WasmEdge::Host::WasiNNLoad &>(FuncInst->getHostFunc());
//   // Get the function "init_execution_context".
//   FuncInst = NNMod->findFuncExports("init_execution_context");
//   EXPECT_NE(FuncInst, nullptr);
//   EXPECT_TRUE(FuncInst->isHostFunction());
//   auto &HostFuncInit = dynamic_cast<WasmEdge::Host::WasiNNInitExecCtx &>(
//       FuncInst->getHostFunc());
//   // Get the function "set_input".
//   FuncInst = NNMod->findFuncExports("set_input");
//   EXPECT_NE(FuncInst, nullptr);
//   EXPECT_TRUE(FuncInst->isHostFunction());
//   auto &HostFuncSetInput =
//       dynamic_cast<WasmEdge::Host::WasiNNSetInput
//       &>(FuncInst->getHostFunc());
//   // Get the function "get_output".
//   FuncInst = NNMod->findFuncExports("get_output");
//   EXPECT_NE(FuncInst, nullptr);
//   EXPECT_TRUE(FuncInst->isHostFunction());
//   auto &HostFuncGetOutput =
//       dynamic_cast<WasmEdge::Host::WasiNNGetOuput
//       &>(FuncInst->getHostFunc());
//   // Get the function "compute".
//   FuncInst = NNMod->findFuncExports("compute");
//   EXPECT_NE(FuncInst, nullptr);
//   EXPECT_TRUE(FuncInst->isHostFunction());
//   auto &HostFuncCompute =
//       dynamic_cast<WasmEdge::Host::WasiNNCompute &>(FuncInst->getHostFunc());

//   // OpenVINO WASI-NN load tests.
//   // Test: load -- meaningless binaries.
//   {
//     EXPECT_TRUE(HostFuncLoad.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             LoadEntryPtr, UINT32_C(2), UINT32_C(0), UINT32_C(0), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Busy));
//   }

//   // Test: load -- graph id ptr out of bounds.
//   {
//     EXPECT_TRUE(HostFuncLoad.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             LoadEntryPtr, UINT32_C(2), UINT32_C(0), UINT32_C(0),
//             OutBoundPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: load -- graph builder ptr out of bounds.
//   {
//     EXPECT_TRUE(HostFuncLoad.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             OutBoundPtr, UINT32_C(2), UINT32_C(0), UINT32_C(0), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: laod -- OpenVINO model xml ptr out of bounds.
//   BuilderPtr = LoadEntryPtr;
//   writeFatPointer(MemInst, OutBoundPtr,
//   static_cast<uint32_t>(XmlRead.size()),
//                   BuilderPtr);
//   writeFatPointer(MemInst, static_cast<uint32_t>(StorePtr + XmlRead.size()),
//                   static_cast<uint32_t>(WeightRead.size()), BuilderPtr);
//   {
//     EXPECT_TRUE(HostFuncLoad.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             LoadEntryPtr, UINT32_C(2), UINT32_C(0), UINT32_C(0), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: load -- OpenVINO model bin ptr out of bounds.
//   BuilderPtr = LoadEntryPtr;
//   writeFatPointer(MemInst, StorePtr, static_cast<uint32_t>(XmlRead.size()),
//                   BuilderPtr);
//   writeFatPointer(MemInst, OutBoundPtr,
//                   static_cast<uint32_t>(WeightRead.size()), BuilderPtr);
//   {
//     EXPECT_TRUE(HostFuncLoad.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             LoadEntryPtr, UINT32_C(2), UINT32_C(0), UINT32_C(0), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: load -- wrong builders' length.
//   BuilderPtr = LoadEntryPtr;
//   writeFatPointer(MemInst, StorePtr, static_cast<uint32_t>(XmlRead.size()),
//                   BuilderPtr);
//   writeFatPointer(MemInst, static_cast<uint32_t>(StorePtr + XmlRead.size()),
//                   static_cast<uint32_t>(WeightRead.size()), BuilderPtr);
//   writeBinaries<uint8_t>(MemInst, XmlRead, StorePtr);
//   writeBinaries<uint8_t>(MemInst, WeightRead,
//                          static_cast<uint32_t>(StorePtr + XmlRead.size()));
//   StorePtr += (XmlRead.size() + WeightRead.size());
//   {
//     EXPECT_TRUE(HostFuncLoad.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             LoadEntryPtr, UINT32_C(4), UINT32_C(0), UINT32_C(0), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: load -- unsupported device. CPU 0, GPU 1, TPU 2
//   {
//     EXPECT_TRUE(HostFuncLoad.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             LoadEntryPtr, UINT32_C(2), UINT32_C(0), UINT32_C(3), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: load -- load successfully.
//   {
//     EXPECT_TRUE(HostFuncLoad.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             LoadEntryPtr, UINT32_C(2), UINT32_C(0), UINT32_C(0), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//     static_cast<uint32_t>(ErrNo::Success));
//     EXPECT_EQ(*MemInst.getPointer<uint32_t *>(BuilderPtr), 0);
//     BuilderPtr += 4;
//   }

//   // Test: load -- load second graph.
//   {
//     EXPECT_TRUE(HostFuncLoad.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             LoadEntryPtr, UINT32_C(2), UINT32_C(0), UINT32_C(0), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//     static_cast<uint32_t>(ErrNo::Success));
//     EXPECT_EQ(*MemInst.getPointer<uint32_t *>(BuilderPtr), 1);
//     BuilderPtr += 4;
//   }

//   // OpenVINO WASI-NN init_execution_context tests.
//   // Test: init_execution_context -- graph id invalid.
//   {
//     EXPECT_TRUE(HostFuncInit.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{UINT32_C(2), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Swap to the tmp. env.
//   NNGraphTmp.emplace_back(Backend::OpenVINO);
//   NNGraphTmp.swap(NNMod->getEnv().NNGraph);
//   NNContextTmp.swap(NNMod->getEnv().NNContext);
//   // Test: init_execution_context -- graph id exceeds.
//   {
//     EXPECT_TRUE(HostFuncInit.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{UINT32_C(0), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::MissingMemory));
//   }
//   // Swap back.
//   NNGraphTmp.swap(NNMod->getEnv().NNGraph);
//   NNContextTmp.swap(NNMod->getEnv().NNContext);

//   // Test: init_execution_context -- init context successfully.
//   {
//     EXPECT_TRUE(HostFuncInit.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{UINT32_C(0), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//     static_cast<uint32_t>(ErrNo::Success));
//     EXPECT_EQ(*MemInst.getPointer<uint32_t *>(BuilderPtr), 0);
//     BuilderPtr += 4;
//   }

//   // Test: init_execution_context -- init second context.
//   {
//     EXPECT_TRUE(HostFuncInit.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{UINT32_C(1), BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//     static_cast<uint32_t>(ErrNo::Success));
//     EXPECT_EQ(*MemInst.getPointer<uint32_t *>(BuilderPtr), 1);
//     BuilderPtr += 4;
//   }

//   // OpenVINO WASI-NN set_input tests.
//   SetInputEntryPtr = BuilderPtr;
//   writeFatPointer(MemInst, StorePtr, static_cast<uint32_t>(TensorDim.size()),
//                   BuilderPtr);
//   writeUInt32(MemInst, UINT32_C(1), BuilderPtr);
//   writeFatPointer(MemInst,
//                   static_cast<uint32_t>(StorePtr + TensorDim.size() * 4),
//                   static_cast<uint32_t>(TensorData.size()), BuilderPtr);
//   writeBinaries<uint32_t>(MemInst, TensorDim, StorePtr);
//   writeBinaries<uint8_t>(
//       MemInst, TensorData,
//       static_cast<uint32_t>(StorePtr + TensorDim.size() * 4));

//   // Swap to the tmp. env.
//   NNContextTmp.emplace_back(NNGraphTmp[0]);
//   NNGraphTmp.swap(NNMod->getEnv().NNGraph);
//   NNContextTmp.swap(NNMod->getEnv().NNContext);
//   // Test: set_input -- context id exceeds.
//   {
//     EXPECT_TRUE(
//         HostFuncSetInput.run(CallFrame,
//                              std::initializer_list<WasmEdge::ValVariant>{
//                                  UINT32_C(3), UINT32_C(0), SetInputEntryPtr},
//                              Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: set_input -- empty context.
//   {
//     EXPECT_TRUE(
//         HostFuncSetInput.run(CallFrame,
//                              std::initializer_list<WasmEdge::ValVariant>{
//                                  UINT32_C(0), UINT32_C(0), SetInputEntryPtr},
//                              Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::MissingMemory));
//   }
//   // Swap back.
//   NNGraphTmp.swap(NNMod->getEnv().NNGraph);
//   NNContextTmp.swap(NNMod->getEnv().NNContext);

//   // Test: set_input -- input index exceeds.
//   {
//     EXPECT_TRUE(
//         HostFuncSetInput.run(CallFrame,
//                              std::initializer_list<WasmEdge::ValVariant>{
//                                  UINT32_C(0), UINT32_C(10),
//                                  SetInputEntryPtr},
//                              Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: set_input -- tensor type not FP32.
//   BuilderPtr = SetInputEntryPtr;
//   writeFatPointer(MemInst, StorePtr, static_cast<uint32_t>(TensorDim.size()),
//                   BuilderPtr);
//   writeUInt32(MemInst, UINT32_C(2), BuilderPtr);
//   writeFatPointer(MemInst,
//                   static_cast<uint32_t>(StorePtr + TensorDim.size() * 4),
//                   static_cast<uint32_t>(TensorData.size()), BuilderPtr);
//   {
//     EXPECT_TRUE(
//         HostFuncSetInput.run(CallFrame,
//                              std::initializer_list<WasmEdge::ValVariant>{
//                                  UINT32_C(0), UINT32_C(0), SetInputEntryPtr},
//                              Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: set_input -- set input successfully.
//   BuilderPtr = SetInputEntryPtr;
//   writeFatPointer(MemInst, StorePtr, static_cast<uint32_t>(TensorDim.size()),
//                   BuilderPtr);
//   writeUInt32(MemInst, UINT32_C(1), BuilderPtr);
//   writeFatPointer(MemInst,
//                   static_cast<uint32_t>(StorePtr + TensorDim.size() * 4),
//                   static_cast<uint32_t>(TensorData.size()), BuilderPtr);
//   {
//     EXPECT_TRUE(
//         HostFuncSetInput.run(CallFrame,
//                              std::initializer_list<WasmEdge::ValVariant>{
//                                  UINT32_C(1), UINT32_C(0), SetInputEntryPtr},
//                              Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//     static_cast<uint32_t>(ErrNo::Success));
//   }
//   StorePtr += (TensorDim.size() * 4 + TensorData.size());

//   // OpenVINO WASI-NN compute tests.
//   // Test: compute -- context id exceeds.
//   {
//     EXPECT_TRUE(HostFuncCompute.run(
//         CallFrame, std::initializer_list<WasmEdge::ValVariant>{UINT32_C(3)},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Swap to the tmp. env.
//   NNGraphTmp.swap(NNMod->getEnv().NNGraph);
//   NNContextTmp.swap(NNMod->getEnv().NNContext);
//   // Test: compute -- empty context.
//   {
//     EXPECT_TRUE(HostFuncCompute.run(
//         CallFrame, std::initializer_list<WasmEdge::ValVariant>{UINT32_C(0)},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Busy));
//   }
//   // Swap back.
//   NNGraphTmp.swap(NNMod->getEnv().NNGraph);
//   NNContextTmp.swap(NNMod->getEnv().NNContext);

//   // Test: compute -- compute successfully.
//   {
//     EXPECT_TRUE(HostFuncCompute.run(
//         CallFrame, std::initializer_list<WasmEdge::ValVariant>{UINT32_C(1)},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//     static_cast<uint32_t>(ErrNo::Success));
//   }

//   // OpenVINO WASI-NN get_output tests.
//   // Test: get_output -- output bytes ptr out of bounds.
//   {
//     EXPECT_TRUE(HostFuncGetOutput.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             UINT32_C(0), UINT32_C(0), StorePtr, 65532, OutBoundPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: get_output -- output buffer ptr out of bounds.
//   {
//     EXPECT_TRUE(HostFuncGetOutput.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             UINT32_C(0), UINT32_C(0), OutBoundPtr, 65532, BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: get_output -- output index exceeds.
//   {
//     EXPECT_TRUE(HostFuncGetOutput.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             UINT32_C(0), UINT32_C(10), StorePtr, 65532, BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//               static_cast<uint32_t>(ErrNo::InvalidArgument));
//   }

//   // Test: get_output -- get output successfully.
//   {
//     EXPECT_TRUE(HostFuncGetOutput.run(
//         CallFrame,
//         std::initializer_list<WasmEdge::ValVariant>{
//             UINT32_C(1), UINT32_C(0), StorePtr, 65532, BuilderPtr},
//         Errno));
//     EXPECT_EQ(Errno[0].get<int32_t>(),
//     static_cast<uint32_t>(ErrNo::Success));
//     EXPECT_EQ(*MemInst.getPointer<uint32_t *>(BuilderPtr), UINT32_C(4004));
//     std::vector<float> OutputClassification(
//         MemInst.getPointer<float *>(StorePtr, 1001) + 1,
//         MemInst.getPointer<float *>(StorePtr, 1001) + 1001);
//     std::vector<size_t> SortedIndex, CorrectClasses{963, 762, 909, 926, 567};
//     SortedIndex = classSort<float>(OutputClassification);
//     // The probability of class i is placed at buffer[i].
//     for (size_t I = 0; I < CorrectClasses.size(); I++) {
//       EXPECT_EQ(SortedIndex[I], CorrectClasses[I]);
//     }
//   }
// }
